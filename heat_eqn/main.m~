function main 
    clear all
    % detailed dt/eta space
    eps = logspace(-4,-1, 30);
    dt  = logspace(-4,-1, 30);
    n = 0;
    
    %% attention this is wrong
    C = 64*sqrt(3e-2)/(2*pi);
    nx = round( 1 + (2*pi)./(C*sqrt(eps)) );
    nx = nx + mod(nx,2);
    
    methods = {@rk2,@sbdf2,@strang_spectral,@swss_spectral,@lie_spectral,@lie_spectral_reverse,@cn2_integrating,@cn2_fd,@strang_fd};
    % loop over methods
    for k = 1:length(methods)
        names{k} = func2str( methods{k} );        
        
        for i=1:length(eps)
            for j=1:length(dt)
                [err(i,j,k), u]=heat( eps(i),methods{k},dt(j),nx(i) );
                n=n+1;
                fprintf('%i of %i ; nx=%i\n',n,length(eps)*length(dt)*length(methods),nx(i))
            end
        end
        
        save heat_strang_const_modified3e-2.mat
        
        [EPS,DT]=meshgrid(eps,dt);
        EPS=EPS';
        DT=DT';
        
        figure
        contourf(EPS,DT,log10(err(:,:,k)), -4:0.10:-1 )        
        caxis([-4 -1])
        set(gca,'yscale','log');    set(gca,'xscale','log');    xlabel('eta');    ylabel('dt');        colorbar;
        line([1e-4 1e-1],[1e-4 1e-1],'color',[1 1 1])
        saveas(gca,['heat_' names{k} '_dxproptoeta.eps'],'epsc')
        title(names{k});
        
        save heat_strang_const_modified3e-2.mat
    end
end


% function main
%     clear all
%     %% time convergence test
%     dt = logspace(-4,-1,10);
%     nx = 512;
%     eps = 1e-1;
% %     methods = {@rk2,@sbdf2,@strang_spectral,@strang_fd,@cn2_integrating,@lie_spectral, @lie_spectral_reverse,@swss_spectral,@cn2_fd};
% %     methods = {@rk2,@sbdf2,@strang_spectral,@cn2_integrating,@lie_spectral,@lie_spectral_reverse,@swss_spectral};%,@strang_fd,@cn2_fd};
%     methods = {@strang_spectral}
%     % just one reference solution by the explicit scheme..
%     [dummy, u_ref] = heat( eps,@rk2,min([0.98*eps 1e-4]),nx );
%         
%     % run naming
%     for j = 1:length(methods)
%         names{j} = func2str( methods{j} );
%     end
%     
%     % dt loops
%     for i = 2:length(dt)
%         for j=1:length(methods)
%             [dummy, u] = heat( eps,methods{j},dt(i),nx );
%             err(i,j) = norm(reshape(u-u_ref,[],1)) / norm(reshape(u_ref,[],1));
%         end
%     end
%     
%     % plot
%     figure
%     loglog(dt, err,'o-')
%     legend( names )
%     title(['eta=' num2str(eps)])    
% end

function [err,u_new]=heat(eps,method,dt_fixed,nx)
    % for rk2, skip this test if it would be unstable
    if (strcmp(func2str(method),'rk2'))
        if (dt_fixed > eps)
            err = 1;
            u_new = zeros(nx+6,nx+6);
            return
        end
    end
        

    addpath(genpath('./lib_spectral_matlab/'))
    addpath(genpath('./lib_finite_differences_matlab/'))
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    global params
    dx = 2*pi / (nx-1);
    % grid in the "fluid"
    params.xf = 2*pi*(0:nx-1)/(nx-1);
    params.x = [-3*dx -2*dx -dx params.xf 2*pi+dx 2*pi+2*dx 2*pi+3*dx];
    params.y = [-3*dx -2*dx -dx params.xf 2*pi+dx 2*pi+2*dx 2*pi+3*dx];
    params.nx           = length(params.x);
    params.ny           = length(params.y);
    params.dx=dx;
    params.dy=dx;
    % the grid is periodic and therefore the last point of x is not the length
    % of the domain, but +dx is.
    params.Lx           = params.x(end)-params.x(1) + dx;
    params.Ly           = params.y(end)-params.y(1) + dx;
    params.eta          = eps;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    params.nu           = 1/10;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    params.T_end        = 0.5; %was 2.5 for error wrt exact solution
    params.dt           = dt_fixed;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    [params.X params.Y] = meshgrid(params.x,params.y);
    params.X            = params.X';
    params.Y            = params.Y';
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    params.mask         = zeros(params.nx,params.ny);
    params.dealias      = zeros(params.nx,params.ny);
    params.us           = zeros(params.nx,params.ny);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % create wavenumber matrices (global)
    % params.kx             = (2*pi/params.Lx)*[0:(params.nx/2-1) (-params.nx/2):(-1)]; % Vector of wavenumbers
    % params.ky             = (2*pi/params.Ly)*[0:(params.ny/2-1) (-params.ny/2):(-1)]; % Vector of wavenumbers
    params.kx             = fmodes(params.nx,params.Lx);
    params.ky             = fmodes(params.ny,params.Ly);
    [params.Kx,params.Ky] = meshgrid(params.kx,params.ky);
    params.Kx             = params.Kx';
    params.Ky             = params.Ky';
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % create the mask
    create_mask();
    % initial condition
    uk_old    = inicond();
    u_old     = cofitxy(uk_old);
    uk_oldold = uk_old*0;
    u_oldold  = u_old*0;

    time = 0;
    it   = 1;

    u_ex = exact_solution();

    % figure
    while (time<params.T_end)
        params.dt = min([ dt_fixed, dt_TIME(time,params.T_end) ]);

        [u_new,uk_new] = method(time,it,u_old,uk_old,u_oldold,uk_oldold);

        u_oldold  = u_old;
        uk_oldold = uk_old;    
        u_old     = u_new;
        uk_old    = uk_new;
        time      = time + params.dt;
        it        = it+1;
        
        % diverged? -> brake
        if (max(max(abs(u_new)))>2) 
            err = 1;
            u_new = zeros(nx+6,nx+6);
            return
        end
        
    end

    err = norm(reshape(u_old-u_ex,[],1))/norm(reshape(u_ex,[],1));

    %    if ( time == params.T_end)
    %        clf
    %        subplot 221
    %        pcolor(X,Y,u1);
    %        farge_color
    %        axis equal
    %        colorbar
    %        shading interp
    %        title(['Temp time=' num2str(time) ' dt=' num2str(params.dt,'%e') ])
    %
    %        subplot 223
    %        pcolor(X,Y,u1-u_ex);
    %        farge_color
    %        axis equal
    %        colorbar
    %        shading interp
    %        title(num2str(err))
    %        drawnow            
    %    end
end












function [u_new, uk_new] = strang_spectral(time,it,u,uk,u_oldold,uk_oldold)
    %% strang splitting for heat eqn, all terms exact, the time error is just the splitting error
    global params
    chi = params.mask; us=params.us;
    %----------------------------------------------------------------------
    % 1st strang step, half a time step for penalization term
    %----------------------------------------------------------------------
    dt1 = 0.5*params.dt; 
    a = dt1/params.eta;    
    u_new  = (u-chi.*us).*exp(-chi*a) + chi.*us;
    uk_new = fft2( u_new );
    uk_new = dealias( uk_new );        
    %----------------------------------------------------------------------
    % 2nd strang step, solve heat eqn for an entire time step
    %----------------------------------------------------------------------
    % exponential factor:    
    vis = exp(-params.nu*params.dt*(params.Kx.^2+params.Ky.^2));    
    uk_new = vis .* uk_new;
    uk_new = dealias( uk_new );
    u_new = cofitxy( uk_new );    
    %----------------------------------------------------------------------
    % 3rd strang step, half a time step for penalization term
    %----------------------------------------------------------------------
    dt1 = 0.5*params.dt; 
    a = dt1/params.eta;  
    u_new  = (u_new-chi.*us).*exp(-chi*a) + chi.*us;
    uk_new = dealias ( fft2(u_new) );
    u_new  = cofitxy( uk_new );
end

function [u_new, uk_new] = lie_spectral(time,it,u,uk,u_oldold,uk_oldold)
    %% first order lie-splitting with spectral discretization
    global params
    % first the penalty term
    chi = params.mask; us=params.us;
    dt1 = params.dt; 
    a = dt1/params.eta;    
    u_new  = (u-chi.*us).*exp(-chi*a) + chi.*us;
    uk_new = fft2( u_new );
    uk_new = dealias( uk_new );        
    % then the laplacian
    vis = exp(-params.nu*params.dt*(params.Kx.^2+params.Ky.^2) );   
    uk_new = vis .* uk_new;
    uk_new = dealias( uk_new );
    u_new = cofitxy( uk_new );    
end

function [u_new, uk_new] = lie_spectral_reverse(time,it,u,uk,u_oldold,uk_oldold)
    %% first order lie-splitting with spectral discretization
    global params
    % then the laplacian
    vis = exp(-params.nu*params.dt*(params.Kx.^2+params.Ky.^2) );   
    uk_new = vis .* uk;
    uk_new = dealias( uk_new );
    u_new = cofitxy( uk_new );    
    
    % first the penalty term
    chi = params.mask;
    us  = params.us;
    dt1 = params.dt; 
    a   = dt1/params.eta;    
    u_new  = (u_new-chi.*us).*exp(-chi*a) + chi.*us;
    uk_new = fft2( u_new );
    uk_new = dealias( uk_new );        
end

function [u_new, uk_new] = swss_spectral(time,it,u_old,uk_old,u_oldold,uk_oldold)
    %% use SWSS splitting instead of strang splitting (almost the same result as strang)
    global params
    chi = params.mask;
    us  = params.us;
    %----------------------------------------------------------------------
    % Part A of SWSS: first penalization, then heat
    %----------------------------------------------------------------------
    % first penalization...
    a = params.dt / params.eta;
    u_a  = (u_old-chi.*us).*exp(-chi*a) + chi.*us;
    % ...now heat eqn
    vis = exp(-params.nu*params.dt*(params.Kx.^2+params.Ky.^2) );  
    uk_a = dealias(fft2(u_a));
    uk_a = vis .* uk_a;    
    %----------------------------------------------------------------------
    % Part B of SWSS: first heat, then penalization
    %----------------------------------------------------------------------
    % first heat...
    vis = exp(-params.nu*params.dt*(params.Kx.^2+params.Ky.^2) );  
    uk_b = dealias(uk_old);
    uk_b = vis .* uk_b;
    u_b = cofitxy( uk_b );    
    % ...then penalization
    a = params.dt / params.eta;
    u_b  = (u_b-chi.*us).*exp(-chi*a) + chi.*us;
    uk_b = dealias( fft2(u_b) );
    %----------------------------------------------------------------------
    % Combine steps A and B
    %----------------------------------------------------------------------
    uk_new = 0.5 * dealias(uk_a + uk_b);
    u_new = cofitxy( uk_new );
end

function [u_new, uk_new] = strang_fd(time,it,u,uk,u_oldold,uk_oldold)
    %% strang splitting with finite differences for the laplacian + CN2
    global params
    chi = params.mask; us=params.us;
    %----------------------------------------------------------------------
    % 1st strang step, half a time step for penalization term
    %----------------------------------------------------------------------
    dt1 = 0.5*params.dt; 
    a = dt1/params.eta;    
    u_new  = (u-chi.*us).*exp(-chi*a) + chi.*us;    
    %----------------------------------------------------------------------
    % 2nd strang step, RK2 time step for NS
    %----------------------------------------------------------------------
    D = sparse(D24p(params.nx,params.dx));
    if ( it == 1 ) || ( params.T_end-time < params.dt ) % do this for the last step as well
        I = speye(params.nx);
        A = kron(D,I) + kron(I,D);
        I = speye( (params.nx)*(params.ny) );
        M = I - params.nu*0.5*params.dt*A;
        [params.L, params.U, params.P, params.Q, params.R] = lu( M );        
    end
    b = u_new + 0.5*params.nu*params.dt*( cofdx_fd(u_new,D)+cofdy_fd(u_new,D) );
    
    u_new = params.Q * (params.U \ (params.L \ (params.P * (params.R \ reshape( b ,[],1))))) ;
    u_new = reshape(u_new,params.nx,params.ny);    
    %----------------------------------------------------------------------
    % 3rd strang step, half a time step for penalization term
    %----------------------------------------------------------------------
    dt1 = 0.5*params.dt; 
    a = dt1/params.eta;  
    u_new  = (u_new-chi.*us).*exp(-chi*a) + chi.*us;
    uk_new = u_new; % dummy argument; discarded
end

function [u_new, uk_new] = cn2_fd(time,it,u,uk,u_oldold,uk_oldold)
    %% ordinary CN2, treating all terms implicitly, no splitting, FD only
    % all terms are treated with the same implicit integrator. This scheme
    % allows eta<<dt and indeed does not show saturation: the color plot is
    % almost vertical lines. this means for a given dt, you CAN decrease
    % eta and really compute the error accordingly. no saturation.
    global params
    chi = params.mask/params.eta;
        
    D = sparse(D24p(params.nx,params.dx));
    if ( it == 1 ) || ( params.T_end-time < params.dt ) % do this for the last step as well
        I = speye(params.nx);
        A = kron(D,I) + kron(I,D);
        I = speye( (params.nx)*(params.ny) );
        M = I - 0.5*params.dt*(params.nu*A - sparse(diag(reshape(chi,[],1))) );
        [params.L, params.U, params.P, params.Q, params.R] = lu( M );        
    end
    
    b = u + 0.5*params.dt*( params.nu*(cofdx_fd(u,D)+cofdy_fd(u,D)) - chi.*u);
    
    u_new = params.Q * (params.U \ (params.L \ (params.P * (params.R \ reshape( b ,[],1))))) ;
    u_new = reshape(u_new,params.nx,params.ny);
    
    uk_new = u_new; % dummy argument; discarded
end

function uk = inicond()
    global params
    u = sin(params.X).*sin(params.Y).*(1-params.mask);
    uk = fft2( u );
end

function create_mask
    global params
    params.mask = ones(params.nx,params.ny);
    params.us   = zeros(params.nx,params.ny);
    
    [dummy,i]=min(abs(params.x-0));
    [dummy,j]=min(abs(params.x-2*pi));
    
    params.mask ( i+1:j-1,i+1:j-1 ) = 0;
end

